#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Sun Jun  7 16:35:51 2020@author: marceloafonseca"""import csvfrom collections import namedtuplefrom math import tan, pi, cos, sin, sqrt, radiansimport matplotlib.pyplot as pltimport numpy as npParams = namedtuple("Params", "l, delta_t, h")# Indices das variaveis:#   X:#       x: 0#       y: 1#       theta: 2#       fx: 3#       fy: 4#   U:#       v: 0#       phi: 1params = Params(l=0.3, delta_t=0.25, h=0.5)def gama(u):    """    Calcula o ângulo percorrido entre 2 passos consecutivos    :param u: parâmetros de comando    :return: gama    """    v = u[0, 0]    phi = u[1, 0]    return (v * params.delta_t * tan(phi)) / (2 * pi * params.l)def r(u):    """    Calcula o raio do arco a ser percorrido dados os parametros de entrada u    :param u: parâmetros de comando    :return: raio    """    gama_ = gama(u)    if gama_ == 0:        return 1000000000  # numero arbitrariamente grande    return params.l / gama(u)def F(mi, u):    """    Calcula o passo de atualização das médias    :param mi: média dos estados anteriores    :param u: parâmetros de comando    :return: atualização das médias    """    r_ = r(u)    gama_ = gama(u)    theta = mi[2, 0]  # precisamos do ', 0' porque mi é um vetor coluna    phi = u[1, 0]    F_delta = np.array(        [            r_ * (cos(theta) * sin(phi) - sin(theta) * (1 - cos(phi))),            r_ * (sin(theta) * sin(phi) - cos(theta) * (1 - cos(phi))),            gama_,            0,            0,        ]    ).reshape((-1, 1))    return mi + F_deltadef A(mi, u):    """    Calcula matriz A para a atualização da matriz Sigma    :param mi: média dos estados anteriores    :param u: parâmetros de comando    :return: A    """    gama_ = gama(u)    r_ = r(u)    theta = mi[2, 0]    A = np.array(        [            [                1,                0,                r_ * (-sin(theta) * sin(gama_) - cos(theta) * (1 - cos(gama_))),                0,                0,            ],            [                0,                1,                r_ * (sin(theta) * sin(gama_) - cos(theta) * (1 - cos(gama_))),                0,                0,            ],            [0, 0, 1, 0, 0],            [0, 0, 0, 1, 0],            [0, 0, 0, 0, 1],        ]    )    return Adef R(mi, u):    """    Calcula matriz R para a atualização da matriz Sigma    :param mi: média dos estados anteriores    :param u: parâmetros de comando    :return: R    """    v = u[0, 0]    l = params.l    delta_t = params.delta_t    theta = mi[2, 0]    s_l2 = (delta_t * v / 6) ** 2    s_r2 = (delta_t * v / 12) ** 2    s_theta2 = (delta_t * v / (8 * l)) ** 2    R = np.array(        [            [                cos(theta) ** 2 * s_l2 + sin(theta) ** 2 * s_r2,                cos(theta) * sin(theta) * (s_l2 - s_r2),                0,                0,                0,            ],            [                cos(theta) * sin(theta) * (s_l2 - s_r2),                sin(theta) ** 2 * s_l2 + cos(theta) ** 2 * s_r2,                0,                0,                0,            ],            [0, 0, s_theta2, 0, 0],            [0, 0, 0, 0, 0],            [0, 0, 0, 0, 0],        ]    )    return Rdef C(mi):    """    Calcula matriz C para o calculo do ganho de kalman e correção de Sigma    :param mi: média dos estados atuais previstos    :param u: parâmetros de comando    :param params: parametros fixos do sistema    :return: R    """    x = mi[0, 0]    y = mi[1, 0]    theta = mi[2, 0]    fx = mi[3, 0]    fy = mi[4, 0]    d = sqrt(x ** 2 + y ** 2 + params.h ** 2)    C = np.array(        [            [x / d, y / d, 0, 0, 0],            [0, 0, -sin(theta) * fx - cos(theta) * fy, cos(theta), -sin(theta)],            [0, 0, -cos(theta) * fx + sin(theta) * fy, -sin(theta), -cos(theta)],        ]    )    return Cdef Q(mi):    """    Calcula a matriz de covariância para o erro de medida    :param mi: média dos estados atuais previstos    :return: matriz de covariância do erro de medida    """    x = mi[0, 0]    y = mi[1, 0]    s_rho2 = (x ** 2 + y ** 2 + params.h * 2) / 400    s_f2 = 1 / 4    s_e2 = 1 / 4    Q = np.array([[s_rho2, 0, 0], [0, s_f2, 0], [0, 0, s_e2]])    return Qdef K(Sigma, C, Q):    """    Calcula a matriz do ganho de Kalman    :param Sigma: matriz Sigma    :param C: matriz C    :param Q: matriz Q    :return: matriz K de ganhos    """    K = Sigma.dot(C.transpose()).dot(        np.linalg.inv((C.dot(Sigma).dot(C.transpose()) + Q))    )    return Kdef G(mi):    """    Calcula a estimativa das observações    :param mi: média dos estados atuais previstos    :return: estimativa das observações no instante atual    """    x = mi[0, 0]    y = mi[1, 0]    theta = mi[2, 0]    fx = mi[3, 0]    fy = mi[4, 0]    G = np.array(        [            [sqrt(x ** 2 + y ** 2 + params.h ** 2)],            [cos(theta) * fx - sin(theta) * fy],            [-sin(theta) * fx - cos(theta) * fy],        ]    )    return Gdef ObtemDados(arquivo):    """    Faz leitura de arquivo csv e retorna matriz com dados    - entrada: arquivo csv    - saidas: dados do arquivo csv transformada em matriz com dados tipo float    """    with open(arquivo) as dados:        leitura_dados = csv.reader(dados, delimiter=",")        matriz_dados = []        dado = [0, 0, 0, 0, 0]        for row in leitura_dados:            dado[0] = float(row[0])            dado[1] = float(row[1])            dado[2] = float(row[2])            dado[3] = float(row[3])            dado[4] = float(row[4])            matriz_dados.append(dado)            dado = [0, 0, 0, 0, 0]    return matriz_dadosdef GraficoXY(matriz_estados, tipo):    """    Recebe matriz com estados e retorna gráfico com posiçoes no plano XY        """    X = []    Y = []    T = []    for estado in matriz_estados:        X.append(estado[0, 0])        Y.append(estado[1, 0])        T.append(estado[2, 0])    # Grafico deterministico    if tipo == 0:        plt.plot(X, Y)        plt.xlabel("Posição em X")        plt.ylabel("Posição em Y")        plt.title("Posição Determinística do Robô Plano XY")        plt.show()    # Grafico corrigido    else:        plt.plot(X, Y)        plt.xlabel("Posição em X")        plt.ylabel("Posição em Y")        plt.title("Posição Corrigida do Robô Plano XY")        plt.show()def ekf(dados, estado_inicial, covariancia_inicial, com_correcao=True):    """    Recebe dados e retorna lista de vetores de estado e lista de matrizes de covariância    - input: dados (csv na forma matricial tipo float), estado_inicial (list), covariancia_inicial (list)    - output: estados (list), covariancias (list)    """    estados = [estado_inicial]    covariancias = [covariancia_inicial]    for t in range(1, len(dados)):        # ======== PARTE 1: PREVISÃO ===================================================        comando = np.array(dados[t]).reshape((-1, 1))[:2]        observacoes = np.array(dados[t]).reshape((-1, 1))[2:]        # Cálculo do vetor de valores médios para cada instante t        mi_barra = F(estados[-1], comando)        # Cálculo da matriz de covariância        A_ = A(estados[-1], comando)        R_ = R(estados[-1], comando)        sigma_barra = A_.dot(covariancias[-1]).dot(A_.transpose()) + R_        # ======== PARTE 2: CORREÇÃO ===================================================        if not com_correcao:            estado_corrigido = mi_barra            covariancia_corrigida = sigma_barra            estados += [estado_corrigido]            covariancias += [covariancia_corrigida]            continue        else:            C_ = C(mi_barra)            Q_ = Q(mi_barra)            K_ = K(sigma_barra, C_, Q_)            mi = mi_barra + K_.dot(observacoes - G(mi_barra))            sigma = (np.eye(K_.shape[0], C_.shape[1]) - K_.dot(C_)).dot(sigma_barra)            estados += [mi]            covariancias += [sigma]    return estados, covariancias